<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Julia Package Listing - Testing Information</title>

    <style>/* -- Mix of julialang.org, Bootstrap 3, and custom -- */
body {
  background-color: white;
  font-family: Georgia, 'Liberation Serif', serif;
  font-size: 14px;
  color: #333;
  line-height: 1.42857143;
}
.site {
  max-width: 785px;
  margin: 2.5em auto 2em;
  padding: 0 1.5em;
}
a {
  color: #428bca;
  text-decoration: none;
}
h1, h2, h3, h4, h5, h6 {
  font-family: inherit;
  font-weight: 500;
  line-height: 1.1;
  color: inherit;
}
h1, h2, h3 {
    margin-top: 20px;
    margin-bottom: 10px;
}
h2 {
  font-size: 30px;
}
h3 {
    font-size: 24px;
}
h4 {
  font-size: 18px;
  margin-top: 10px;
  margin-bottom: 10px;
}
.titlebox {
  text-align: center;
  font-size: 120%;
  margin-top: 3em;
}
.ok     { background-color: #11AA11; } /*Tests passing*/
.fail   { background-color: #DD3333; } /*Tests failed*/
.skip   { background-color: #3333DD; } /*Tests skipped*/
.kill   { background-color: #222222; } /*Tests interrupted*/
.statusbox {
  width: 12px;
  height: 12px;
  display: inline-block;
}
hr {
  margin-top: 10px;
  margin-bottom: 0px;
  border: 0;
  border-top: 1px solid #eee;
}
.pkglisting h2 { margin-bottom: 0px; }
pre {margin: 0;}
@media (min-width: 785px) {
  .pkglisting {
    display: table;
    width: 100%;
  }
  .pkgnamedesc {
    display: table-cell;
    width: 50%;
  }
  .pkgvertest {
    display: table-cell;
    width:50%;
    text-align: right
  }
}
/* collapsible sections */
.collapsible {
  font-family: Georgia, 'Liberation Serif', serif;
  font-size: 14px;
  background: none;
  border: none;
  margin: 0;
  padding: 0;
  cursor: pointer;
}
.content {
  display: none;
  overflow: hidden;
}
</style>
  </head>

  <body>
  <div class="site">
    <!-- HEADER -->
    <div class="titlebox">
        <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="210px" height="142px" viewBox="0 0 310 216" enable-background="new 0 0 310 216" xml:space="preserve">

<!-- blue dot -->
<circle fill="#6b85dd" stroke="#4266d5" stroke-width="3" cx="50.5" cy="58.665" r="16.5"></circle>
<!-- red dot -->
<circle fill="#d66661" stroke="#c93d39" stroke-width="3" cx="212.459" cy="60.249" r="16.5"></circle>
<!-- green dot -->
<circle fill="#6bab5b" stroke="#3b972e" stroke-width="3" cx="233.834" cy="23.874" r="16.5"></circle>
<!-- purple dot -->
<circle fill="#aa7dc0" stroke="#945bb0" stroke-width="3" cx="255.459" cy="59.999" r="16.5"></circle>

<!-- "j" -->
<path fill="#252525" d="M37.216,138.427c0-15.839,0.006-31.679-0.018-47.517c-0.001-0.827,0.169-1.234,1.043-1.47
    c7.876-2.127,15.739-4.308,23.606-6.47c1.33-0.366,1.333-0.36,1.333,1.019c0,25.758,0.015,51.517-0.012,77.274
    c-0.006,5.514,0.245,11.032-0.272,16.543c-0.628,6.69-2.15,13.092-6.438,18.506c-3.781,4.771-8.898,7.25-14.767,8.338
    c-6.599,1.222-13.251,1.552-19.934,0.938c-4.616-0.423-9.045-1.486-12.844-4.363c-2.863-2.168-4.454-4.935-3.745-8.603
    c0.736-3.806,3.348-5.978,6.861-7.127c2.262-0.74,4.628-0.872,6.994-0.53c1.823,0.264,3.42,1.023,4.779,2.288
    c1.38,1.284,2.641,2.674,3.778,4.177c0.872,1.15,1.793,2.256,2.991,3.086c2.055,1.426,4,0.965,5.213-1.216
    c0.819-1.473,0.997-3.106,1.173-4.731c0.255-2.348,0.255-4.707,0.256-7.062C37.218,167.145,37.216,152.786,37.216,138.427z"></path>

<!-- "u" -->
<path fill="#252525" d="M125.536,162.479c-2.908,2.385-5.783,4.312-8.88,5.904c-10.348,5.323-20.514,4.521-30.324-1.253
    c-6.71-3.95-11.012-9.849-12.52-17.606c-0.236-1.213-0.363-2.438-0.363-3.688c0.01-19.797,0.017-39.593-0.02-59.39
    c-0.002-1.102,0.285-1.357,1.363-1.351c7.798,0.049,15.597,0.044,23.396,0.003c0.95-0.005,1.177,0.25,1.175,1.183
    c-0.027,19.356-0.025,38.713-0.018,58.07c0.002,6.34,3.599,10.934,9.672,12.42c2.13,0.521,4.19,0.396,6.173-0.6
    c4.26-2.139,7.457-5.427,10.116-9.307c0.333-0.487,0.224-1,0.224-1.51c0.007-19.635,0.016-39.271-0.02-58.904
    c-0.002-1.083,0.255-1.369,1.353-1.361c7.838,0.052,15.677,0.045,23.515,0.004c0.916-0.005,1.103,0.244,1.102,1.124
    c-0.025,27.677-0.026,55.353,0.002,83.024c0.001,0.938-0.278,1.099-1.139,1.095c-7.918-0.028-15.837-0.028-23.756-0.001
    c-0.815,0.003-1.1-0.166-1.073-1.037C125.581,167.117,125.536,164.928,125.536,162.479z"></path>

<!-- "l" -->
<path fill="#252525" d="M187.423,107.08c0,20.637-0.011,41.273,0.026,61.91c0.003,1.119-0.309,1.361-1.381,1.355
    c-7.799-0.052-15.598-0.047-23.396-0.008c-0.898,0.008-1.117-0.222-1.115-1.115c0.021-39.074,0.021-78.147,0-117.226
    c0-0.811,0.189-1.169,1.006-1.392c7.871-2.149,15.73-4.327,23.584-6.545c1.045-0.295,1.308-0.17,1.306,0.985
    C187.412,65.727,187.423,86.403,187.423,107.08z"></path>

<!-- "i" -->
<path fill="#252525" d="M223.46,126.477c0,14.155-0.011,28.312,0.021,42.467c0.002,1.027-0.164,1.418-1.332,1.408
    c-7.838-0.061-15.676-0.047-23.516-0.01c-0.881,0.004-1.121-0.189-1.119-1.104c0.026-26.153,0.025-52.307,0-78.458
    c0-0.776,0.203-1.101,0.941-1.302c7.984-2.172,15.972-4.35,23.938-6.596c1.049-0.296,1.08,0.031,1.078,0.886
    C223.454,98.004,223.46,112.239,223.46,126.477z"></path>

<!-- "a" -->
<path fill="#252525" d="M277.695,163.6c-0.786,0.646-1.404,1.125-2,1.635c-4.375,3.746-9.42,5.898-15.16,6.42
    c-5.792,0.527-11.479,0.244-16.934-2.047c-12.08-5.071-15.554-17.188-11.938-27.448c1.799-5.111,5.472-8.868,9.831-11.94
    c5.681-4.003,12.009-6.732,18.504-9.074c5.576-2.014,11.186-3.939,16.955-5.347c0.445-0.104,0.773-0.243,0.757-0.854
    c-0.136-4.389,0.261-8.79-0.479-13.165c-1.225-7.209-6.617-10.013-12.895-9.348c-0.516,0.055-1.029,0.129-1.536,0.241
    c-4.877,1.081-7.312,4.413-7.374,10.127c-0.02,1.729-0.229,3.418-0.693,5.084c-0.906,3.229-2.969,5.354-6.168,6.266
    c-3.422,0.979-6.893,0.998-10.23-0.305c-6.529-2.543-8.877-10.164-5.12-16.512c2.249-3.799,5.606-6.4,9.461-8.405
    c6.238-3.246,12.914-4.974,19.896-5.537c7.565-0.61,15.096-0.366,22.49,1.507c4.285,1.085,8.312,2.776,11.744,5.657
    c4.473,3.749,6.776,8.647,6.812,14.374c0.139,21.477,0.096,42.951,0.143,64.428c0.002,0.799-0.248,0.983-1.021,0.98
    c-8.035-0.025-16.074-0.023-24.113-0.001c-0.716,0.002-0.973-0.146-0.941-0.915C277.736,167.562,277.695,165.698,277.695,163.6z
     M277.695,126.393c-4.793,2.104-9.25,4.373-13.287,7.408c-2.151,1.618-4.033,3.483-5.732,5.581
    c-4.229,5.226-1.988,13.343,1.693,16.599c1.592,1.406,3.359,1.906,5.419,1.521c1.621-0.307,3.149-0.857,4.549-1.734
    c1.521-0.951,2.949-2.072,4.539-2.887c2.31-1.18,2.97-2.861,2.894-5.445C277.561,140.484,277.695,133.527,277.695,126.393z"></path>

</svg>

        <h1>
          <a name="ChainRules">ChainRules</a>
        </h1>

        <p>
          <a href="../index.html#ChainRules">← Back to package list</a>
        </p>

    </div>

    <p>
      If you think that there is an error in how your package is being tested or represented, please file an issue at <a href="https://github.com/JuliaComputing/NewPkgEval.jl">NewPkgEval.jl</a>, making sure to read the FAQ first.
    </p>


    <h3>Results with Julia v1.2.0</h3>

    <p>
      Testing was <strong>unsuccessful</strong>: package has test failures.
      Last evaluation was  ago and took 18 minutes, 2 seconds.
    </p>

    <p>
      Click <a href="/home/maleadt/Julia/pkg/NewPkgEval/site/build/logs/ChainRules/1.2.0.log">here</a> to download the log file.
      
    </p>

      <button class="collapsible">Click here to show the log contents.</button>
      <div class="content">
      <pre> Resolving package versions...
 Installed Requires ─────── v0.5.2
 Installed Reexport ─────── v0.2.0
 Installed ChainRulesCore ─ v0.4.0
 Installed ChainRules ───── v0.2.3
  Updating `~&#x2F;.julia&#x2F;environments&#x2F;v1.2&#x2F;Project.toml`
  [082447d4] + ChainRules v0.2.3
  Updating `~&#x2F;.julia&#x2F;environments&#x2F;v1.2&#x2F;Manifest.toml`
  [082447d4] + ChainRules v0.2.3
  [d360d2e6] + ChainRulesCore v0.4.0
  [189a3867] + Reexport v0.2.0
  [ae029012] + Requires v0.5.2
  [2a0f44e3] + Base64 
  [ade2ca70] + Dates 
  [8ba89e20] + Distributed 
  [b77e0a4c] + InteractiveUtils 
  [76f85450] + LibGit2 
  [8f399da3] + Libdl 
  [37e2e46d] + LinearAlgebra 
  [56ddb016] + Logging 
  [d6f4376e] + Markdown 
  [44cfe95a] + Pkg 
  [de0858da] + Printf 
  [3fa0cd96] + REPL 
  [9a3f8284] + Random 
  [ea8e919c] + SHA 
  [9e88b42a] + Serialization 
  [6462fe0b] + Sockets 
  [2f01184e] + SparseArrays 
  [10745b16] + Statistics 
  [8dfed614] + Test 
  [cf7118a7] + UUIDs 
  [4ec0a83e] + Unicode 
   Testing ChainRules
 Resolving package versions...
 Installed NaNMath ─────────── v0.3.3
 Installed FiniteDifferences ─ v0.9.0
 Installed Compat ──────────── v2.2.0
 Installed URIParser ───────── v0.4.0
 Installed SpecialFunctions ── v0.8.0
 Installed BinDeps ─────────── v0.8.10
 Installed BinaryProvider ──── v0.5.8
  Building SpecialFunctions → `~&#x2F;.julia&#x2F;packages&#x2F;SpecialFunctions&#x2F;ne2iw&#x2F;deps&#x2F;build.log`
    Status `&#x2F;tmp&#x2F;jl_XLkmQM&#x2F;Manifest.toml`
  [9e28174c] BinDeps v0.8.10
  [b99e7846] BinaryProvider v0.5.8
  [082447d4] ChainRules v0.2.3
  [d360d2e6] ChainRulesCore v0.4.0
  [34da2185] Compat v2.2.0
  [26cc04aa] FiniteDifferences v0.9.0
  [77ba4419] NaNMath v0.3.3
  [189a3867] Reexport v0.2.0
  [ae029012] Requires v0.5.2
  [276daf66] SpecialFunctions v0.8.0
  [30578b45] URIParser v0.4.0
  [2a0f44e3] Base64  [`@stdlib&#x2F;Base64`]
  [ade2ca70] Dates  [`@stdlib&#x2F;Dates`]
  [8bb1440f] DelimitedFiles  [`@stdlib&#x2F;DelimitedFiles`]
  [8ba89e20] Distributed  [`@stdlib&#x2F;Distributed`]
  [b77e0a4c] InteractiveUtils  [`@stdlib&#x2F;InteractiveUtils`]
  [76f85450] LibGit2  [`@stdlib&#x2F;LibGit2`]
  [8f399da3] Libdl  [`@stdlib&#x2F;Libdl`]
  [37e2e46d] LinearAlgebra  [`@stdlib&#x2F;LinearAlgebra`]
  [56ddb016] Logging  [`@stdlib&#x2F;Logging`]
  [d6f4376e] Markdown  [`@stdlib&#x2F;Markdown`]
  [a63ad114] Mmap  [`@stdlib&#x2F;Mmap`]
  [44cfe95a] Pkg  [`@stdlib&#x2F;Pkg`]
  [de0858da] Printf  [`@stdlib&#x2F;Printf`]
  [3fa0cd96] REPL  [`@stdlib&#x2F;REPL`]
  [9a3f8284] Random  [`@stdlib&#x2F;Random`]
  [ea8e919c] SHA  [`@stdlib&#x2F;SHA`]
  [9e88b42a] Serialization  [`@stdlib&#x2F;Serialization`]
  [1a1011a3] SharedArrays  [`@stdlib&#x2F;SharedArrays`]
  [6462fe0b] Sockets  [`@stdlib&#x2F;Sockets`]
  [2f01184e] SparseArrays  [`@stdlib&#x2F;SparseArrays`]
  [10745b16] Statistics  [`@stdlib&#x2F;Statistics`]
  [8dfed614] Test  [`@stdlib&#x2F;Test`]
  [cf7118a7] UUIDs  [`@stdlib&#x2F;UUIDs`]
  [4ec0a83e] Unicode  [`@stdlib&#x2F;Unicode`]
WARNING: Method definition rrule(typeof(Base.sum), AbstractArray{#s677, N} where N where #s677&lt;:Real) in module ChainRules at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;src&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:61 overwritten at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;src&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:76.
  ** incremental compilation may be fatally broken for this module **

Testing ChainRules.jl
sincos: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sincos), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:78
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:74
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:55
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:3
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
identity: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(identity), ::Float64, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Float64, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:152
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:151
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
identity: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(identity), ::Array{Float64,1}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:153
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:151
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
mapreduce: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:25
  Test threw exception
  Expression: ≈(x̄_ad, x̄_fd, atol=1.0e-9, rtol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; atol=1.0e-9, rtol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Array{Float64,2},typeof(abs2),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Array{Float64,2},typeof(abs2),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:25
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:12
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Vector: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Float64,typeof(identity),Array{Float64,1}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Float64,typeof(identity),Array{Float64,1}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:39
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:37
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Matrix: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Float64,typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Float64,typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:44
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:42
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Array{T, 3}: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,3}, ::Tuple{Array{Float64,3}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Float64,typeof(identity),Array{Float64,3}}}, ::Tuple{Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Float64,typeof(identity),Array{Float64,3}}}, ::Tuple{Array{Float64,3}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,3},Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,3},Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:49
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:47
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
keyword arguments: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:65
  Test threw exception
  Expression: ≈(x̄_ad, x̄_fd, atol=1.0e-9, rtol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; atol=1.0e-9, rtol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Array{Float64,2},typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##600#603&quot;)){Array{Float64,2},typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:65
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:58
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
 Basic: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##630#632&quot;)){Float64,getfield(ChainRules, Symbol(&quot;#sum_pullback#622&quot;)){getfield(ChainRules, Symbol(&quot;#sum_pullback#620&quot;)){getfield(ChainRules, Symbol(&quot;#mapreduce_pullback#602&quot;)){typeof(identity),Array{Float64,1}}}},Int64}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##630#632&quot;)){Float64,getfield(ChainRules, Symbol(&quot;#sum_pullback#622&quot;)){getfield(ChainRules, Symbol(&quot;#sum_pullback#620&quot;)){getfield(ChainRules, Symbol(&quot;#mapreduce_pullback#602&quot;)){typeof(identity),Array{Float64,1}}}},Int64}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(mean), ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:6
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:6
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:2
  
with dims kwargs: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:31
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-9, atol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:31
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:25
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:2
  
 inv: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(inv), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:37
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
det: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##724#726&quot;)){Float64,Array{Float64,2},Float64}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##724#726&quot;)){Float64,Array{Float64,2},Float64}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(det), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:43
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:40
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
logdet: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##728#730&quot;)){Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##728#730&quot;)){Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logdet), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:49
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:46
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
tr: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##732#734&quot;)){Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##732#734&quot;)){Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(tr), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:54
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:52
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##772#774&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##772#774&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:4
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##772#774&quot;)){Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##772#774&quot;)){Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:6
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##772#774&quot;)){Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##772#774&quot;)){Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:8
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:21
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:22
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Array{Float64,2},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,2},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:23
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##775#777&quot;)){Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:24
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Symmetric: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##783#785&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##783#785&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:28
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:27
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Adjoint{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##786#788&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##786#788&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Adjoint{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##789#791&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##789#791&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Adjoint{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##792#794&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##792#794&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(adjoint), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Adjoint{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##795#797&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##795#797&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(adjoint), ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Transpose{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##798#800&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##798#800&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Transpose{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##801#803&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##801#803&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Transpose{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##804#806&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##804#806&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(transpose), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Transpose{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##807#809&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##807#809&quot;)){Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(transpose), ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
UpperTriangular: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##810#812&quot;)){UpperTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##810#812&quot;)){UpperTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::UpperTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::UpperTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:40
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:37
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
LowerTriangular: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##813#815&quot;)){LowerTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::getfield(Base, Symbol(&quot;#kw##isapprox&quot;)))(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{getfield(ChainRules, Symbol(&quot;##813#815&quot;)){LowerTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::LowerTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::LowerTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:40
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1186
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:37
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1442
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
 ┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = rrule(::typeof(lgamma), ::Float64) at rule_definition_tools.jl:207
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:207
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = #test_scalar#3(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(test_scalar), ::typeof(lgamma), ::Float64) at test_util.jl:30
└ @ Main ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:30
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = fdm(::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::typeof(lgamma), ::Float64, ::Val{true}) at methods.jl:222
└ @ FiniteDifferences ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:222
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::getfield(FiniteDifferences, Symbol(&quot;##20#22&quot;)){typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::getfield(FiniteDifferences, Symbol(&quot;##20#22&quot;)){typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::getfield(FiniteDifferences, Symbol(&quot;##20#22&quot;)){typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = #20 at methods.jl:263 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::getfield(FiniteDifferences, Symbol(&quot;##20#22&quot;)){typeof(lgamma),Float64,UnitRange{Int64},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::getfield(FiniteDifferences, Symbol(&quot;##20#22&quot;)){typeof(lgamma),Float64,UnitRange{Int64},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = frule(::typeof(lgamma), ::Float64) at rule_definition_tools.jl:178
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:178
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:69
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:70
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:256
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Test&#x2F;src&#x2F;Test.jl:1113
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = rrule(::typeof(lgamma), ::Complex{Float64}) at rule_definition_tools.jl:207
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:207
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #test_scalar#3(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(test_scalar), ::typeof(lgamma), ::Complex{Float64}) at test_util.jl:30
└ @ Main ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:30
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = frule(::typeof(lgamma), ::Complex{Float64}) at rule_definition_tools.jl:178
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:178
Test Summary:                           | Pass  Error  Total
ChainRules                              | 7529     62   7591
  helper functions                      |   12            12
  rulesets                              | 7517     62   7579
    Base                                | 1447      8   1455
      base                              | 1280      3   1283
        Trig                            |  568      1    569
          Basics                        |   56            56
          Basics                        |   72            72
          Hyperbolic                    |   42            42
          Hyperbolic                    |   54            54
          Degrees                       |   42            42
          Inverses                      |   42            42
          Inverses                      |   54            54
          Inverse hyperbolic            |   42            42
          Inverse hyperbolic            |   54            54
          Inverse degrees               |   42            42
          Inverse degrees               |   54            54
          Multivariate                  |   14      1     15
            atan2                       |    5             5
            sincos                      |    9      1     10
        math                            |  311           311
        Unary complex functions         |  224           224
        *(x, y)                         |   16            16
        binary trig (hypot)             |   16            16
        binary trig (atan)              |   16            16
        identity                        |   17      2     19
        Constants                       |   14            14
        Constants                       |   14            14
        Constants                       |   18            18
        Constants                       |   18            18
        Constants                       |   18            18
        sign                            |   30            30
      reshape                           |    9             9
      hcat                              |    5             5
      vcat                              |    5             5
      fill                              |    8             8
      Maps and Reductions               |  132      5    137
        map                             |   33            33
        mapreduce                       |   13      1     14
        mapfoldl                        |   13            13
        mapfoldr                        |   13            13
        sum                             |   60      4     64
          Vector                        |   12      1     13
          Matrix                        |   12      1     13
          Array{T, 3}                   |   12      1     13
          function argument             |   24            24
          keyword arguments             |           1      1
      broadcast                         |    8             8
    Statistics                          |   22      2     24
      mean                              |   22      2     24
        Basic                           |   10      1     11
        with function arg               |   12            12
        with dims kwargs                |           1      1
    LinearAlgebra                       | 5137     49   5186
      linalg                            | 1299      4   1303
        dot                             |   66            66
        inv                             |   12      1     13
        det                             |   12      1     13
        logdet                          |   12      1     13
        tr                              |   12      1     13
        *                               |  500           500
        &#x2F;                               |  260           260
        \                               |  360           360
        norm                            |   65            65
      Structured Matrices               |  200     18    218
        Diagonal                        |   30      3     33
        ::Diagonal * ::AbstractVector   |   20            20
        diag                            |   40      4     44
        Symmetric                       |   10      1     11
        Adjoint                         |   20      2     22
        adjoint                         |   20      2     22
        Transpose                       |   20      2     22
        transpose                       |   20      2     22
        UpperTriangular                 |   10      1     11
        LowerTriangular                 |   10      1     11
      Factorizations                    |  128     27    155
        svd                             |  102     27    129
          Vt                            |    1             1
          Vt                            |    1             1
          Vt                            |    1             1
          Vt                            |    1             1
          Vt                            |    1             1
          Vt                            |    1             1
          Vt                            |    1             1
          Vt                            |    1             1
          Vt                            |    1             1
          accumulate!                   |    9             9
          Helper functions              |    3             3
        cholesky                        |   26            26
      BLAS                              | 3510          3510
    packages                            |  911      3    914
      SpecialFunctions                  |  119           119
      SpecialFunctions                  |   84            84
      SpecialFunctions                  |   84            84
      SpecialFunctions                  |  133           133
      SpecialFunctions                  |  119           119
      SpecialFunctions                  |   84            84
      SpecialFunctions                  |  144           144
      log gamma and co                  |  144      3    147
        lgamma at 1.5, rrule            |    4             4
        lgamma at 1.5, frule            |    3             3
        loggamma at 1.5, rrule          |    4             4
        loggamma at 1.5, frule          |    3             3
        lgamma at 2.5, rrule            |    4             4
        lgamma at 2.5, frule            |    3             3
        loggamma at 2.5, rrule          |    4             4
        loggamma at 2.5, frule          |    3             3
        lgamma at 10.5, rrule           |    4             4
        lgamma at 10.5, frule           |    3             3
        loggamma at 10.5, rrule         |    4             4
        loggamma at 10.5, frule         |    3             3
        lgamma at -0.6, rrule           |    4             4
        lgamma at -0.6, frule           |    3             3
        lgamma at -2.6, rrule           |    4             4
        lgamma at -2.6, frule           |    3             3
        lgamma at -3.3, rrule           |    4             4
        lgamma at -3.3, frule           |    3             3
        lgamma at 1.6 + 1.6im, rrule    |    5             5
        lgamma at 1.6 + 1.6im, frule    |    4             4
        loggamma at 1.6 + 1.6im, rrule  |    5             5
        loggamma at 1.6 + 1.6im, frule  |    4             4
        lgamma at 1.6 - 1.6im, rrule    |    5             5
        lgamma at 1.6 - 1.6im, frule    |    4             4
        loggamma at 1.6 - 1.6im, rrule  |    5             5
        loggamma at 1.6 - 1.6im, frule  |    4             4
        lgamma at -4.6 + 1.6im, rrule   |    5             5
        lgamma at -4.6 + 1.6im, frule   |    4             4
        loggamma at -4.6 + 1.6im, rrule |    5             5
        loggamma at -4.6 + 1.6im, frule |    4             4
ERROR: LoadError: Some tests did not pass: 7529 passed, 0 failed, 62 errored, 0 broken.
in expression starting at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;runtests.jl:22
ERROR: Package ChainRules errored during testing
Stacktrace:
 [1] pkgerror(::String, ::Vararg{String,N} where N) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;Types.jl:112
 [2] #test#119(::Bool, ::Nothing, ::typeof(Pkg.Operations.test), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;Operations.jl:1288
 [3] #test at .&#x2F;none:0 [inlined]
 [4] #test#62(::Bool, ::Nothing, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.test), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:245
 [5] test at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:233 [inlined]
 [6] #test#61 at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:230 [inlined]
 [7] test at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:230 [inlined]
 [8] #test#60 at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:229 [inlined]
 [9] test at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:229 [inlined]
 [10] #test#59(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.test), ::String) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:228
 [11] test(::String) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.2&#x2F;Pkg&#x2F;src&#x2F;API.jl:228
 [12] top-level scope at none:10
</pre>
      </div>

    <h3>Results with Julia v1.3.0</h3>

    <p>
      Testing was <strong>unsuccessful</strong>: package has test failures.
      Last evaluation was  ago and took 15 minutes, 7 seconds.
    </p>

    <p>
      Click <a href="/home/maleadt/Julia/pkg/NewPkgEval/site/build/logs/ChainRules/1.3.0.log">here</a> to download the log file.
      
    </p>

      <button class="collapsible">Click here to show the log contents.</button>
      <div class="content">
      <pre> Resolving package versions...
 Installed Requires ─────── v0.5.2
 Installed Reexport ─────── v0.2.0
 Installed ChainRulesCore ─ v0.4.0
 Installed ChainRules ───── v0.2.3
  Updating `~&#x2F;.julia&#x2F;environments&#x2F;v1.3&#x2F;Project.toml`
  [082447d4] + ChainRules v0.2.3
  Updating `~&#x2F;.julia&#x2F;environments&#x2F;v1.3&#x2F;Manifest.toml`
  [082447d4] + ChainRules v0.2.3
  [d360d2e6] + ChainRulesCore v0.4.0
  [189a3867] + Reexport v0.2.0
  [ae029012] + Requires v0.5.2
  [2a0f44e3] + Base64 
  [ade2ca70] + Dates 
  [8ba89e20] + Distributed 
  [b77e0a4c] + InteractiveUtils 
  [76f85450] + LibGit2 
  [8f399da3] + Libdl 
  [37e2e46d] + LinearAlgebra 
  [56ddb016] + Logging 
  [d6f4376e] + Markdown 
  [44cfe95a] + Pkg 
  [de0858da] + Printf 
  [3fa0cd96] + REPL 
  [9a3f8284] + Random 
  [ea8e919c] + SHA 
  [9e88b42a] + Serialization 
  [6462fe0b] + Sockets 
  [2f01184e] + SparseArrays 
  [10745b16] + Statistics 
  [8dfed614] + Test 
  [cf7118a7] + UUIDs 
  [4ec0a83e] + Unicode 
   Testing ChainRules
 Resolving package versions...
 Installed NaNMath ─────────── v0.3.3
 Installed SpecialFunctions ── v0.9.0
 Installed FiniteDifferences ─ v0.9.0
 Installed OpenSpecFun_jll ─── v0.5.3+1
    Status `&#x2F;tmp&#x2F;jl_n0YzSH&#x2F;Manifest.toml`
  [082447d4] ChainRules v0.2.3
  [d360d2e6] ChainRulesCore v0.4.0
  [26cc04aa] FiniteDifferences v0.9.0
  [77ba4419] NaNMath v0.3.3
  [efe28fd5] OpenSpecFun_jll v0.5.3+1
  [189a3867] Reexport v0.2.0
  [ae029012] Requires v0.5.2
  [276daf66] SpecialFunctions v0.9.0
  [2a0f44e3] Base64  [`@stdlib&#x2F;Base64`]
  [ade2ca70] Dates  [`@stdlib&#x2F;Dates`]
  [8ba89e20] Distributed  [`@stdlib&#x2F;Distributed`]
  [b77e0a4c] InteractiveUtils  [`@stdlib&#x2F;InteractiveUtils`]
  [76f85450] LibGit2  [`@stdlib&#x2F;LibGit2`]
  [8f399da3] Libdl  [`@stdlib&#x2F;Libdl`]
  [37e2e46d] LinearAlgebra  [`@stdlib&#x2F;LinearAlgebra`]
  [56ddb016] Logging  [`@stdlib&#x2F;Logging`]
  [d6f4376e] Markdown  [`@stdlib&#x2F;Markdown`]
  [44cfe95a] Pkg  [`@stdlib&#x2F;Pkg`]
  [de0858da] Printf  [`@stdlib&#x2F;Printf`]
  [3fa0cd96] REPL  [`@stdlib&#x2F;REPL`]
  [9a3f8284] Random  [`@stdlib&#x2F;Random`]
  [ea8e919c] SHA  [`@stdlib&#x2F;SHA`]
  [9e88b42a] Serialization  [`@stdlib&#x2F;Serialization`]
  [6462fe0b] Sockets  [`@stdlib&#x2F;Sockets`]
  [2f01184e] SparseArrays  [`@stdlib&#x2F;SparseArrays`]
  [10745b16] Statistics  [`@stdlib&#x2F;Statistics`]
  [8dfed614] Test  [`@stdlib&#x2F;Test`]
  [cf7118a7] UUIDs  [`@stdlib&#x2F;UUIDs`]
  [4ec0a83e] Unicode  [`@stdlib&#x2F;Unicode`]
WARNING: Method definition rrule(typeof(Base.sum), AbstractArray{#s677, N} where N where #s677&lt;:Real) in module ChainRules at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;src&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:61 overwritten at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;src&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:76.
  ** incremental compilation may be fatally broken for this module **

Testing ChainRules.jl
sincos: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sincos), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:78
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:74
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:55
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:3
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
identity: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(identity), ::Float64, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Float64, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:152
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:151
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
identity: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(identity), ::Array{Float64,1}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:153
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:151
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
mapreduce: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:25
  Test threw exception
  Expression: ≈(x̄_ad, x̄_fd, atol=1.0e-9, rtol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; atol=1.0e-9, rtol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(abs2),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(abs2),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:25
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:12
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Vector: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,1}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,1}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:39
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:37
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Matrix: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:44
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:42
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Array{T, 3}: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,3}, ::Tuple{Array{Float64,3}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,3}}}, ::Tuple{Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,3}}}, ::Tuple{Array{Float64,3}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,3},Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,3},Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:49
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:47
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
keyword arguments: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:65
  Test threw exception
  Expression: ≈(x̄_ad, x̄_fd, atol=1.0e-9, rtol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; atol=1.0e-9, rtol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:65
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:58
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
 Basic: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#630#632&quot;{Float64,ChainRules.var&quot;#sum_pullback#622&quot;{ChainRules.var&quot;#sum_pullback#620&quot;{ChainRules.var&quot;#mapreduce_pullback#602&quot;{typeof(identity),Array{Float64,1}}}},Int64}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#630#632&quot;{Float64,ChainRules.var&quot;#sum_pullback#622&quot;{ChainRules.var&quot;#sum_pullback#620&quot;{ChainRules.var&quot;#mapreduce_pullback#602&quot;{typeof(identity),Array{Float64,1}}}},Int64}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(mean), ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:6
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:6
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:2
  
with dims kwargs: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:31
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-9, atol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:31
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:25
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:2
  
 inv: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(inv), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:37
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
det: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#724#726&quot;{Float64,Array{Float64,2},Float64}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#724#726&quot;{Float64,Array{Float64,2},Float64}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(det), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:43
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:40
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
logdet: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#728#730&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#728#730&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logdet), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:49
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:46
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
tr: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#732#734&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#732#734&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(tr), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:54
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:52
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
Matrix: Test Failed at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:195
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
   Evaluated: isapprox(Thunk(ChainRules.var&quot;#755#758&quot;{Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}([-0.9827718177516547 -3.049187087985662 -0.45753014518031915 0.049550548181828; -1.1457095184571038 -1.281790532097414 -0.7991285413217107 -0.8913053693383933; 0.25819205428715203 2.8015194483397003 1.0753460926351635 -0.7053146611866707; -2.282547976724439 0.5639614209301308 -0.5569593865129592 1.3970437844025363], [-0.34807928510100733 0.8718983568753548 -1.3002596896606895 -0.4385362125324239; -0.19506959830062723 -0.007206357093314457 -1.0059040824152614 -0.09173118968880091; -0.5497606187369344 -0.6163495955240155 0.6796485760534101 1.22561207137653; 1.0808323747949233 -0.5801739513350528 -0.043207370167515954 -0.232131676978592; -2.2125060475463463 -1.5612897485472592 -0.039839626218822005 -1.2139396904067505], [-0.23690460123730323 -1.7170129974387656 1.604831121738095 -0.330419660506073; -0.3827075659919168 -2.446261897220929 1.7480788262457672 -0.2672312785080624; -1.9688978438045297 -0.26713540122649804 0.9166815687612451 1.200964147356692; -1.5797479817238906 0.6778692338783507 1.1341703209400371 1.3170491877286854; -0.5654974841550139 -0.1689008828898645 -2.1775754411288144 0.6023924017880021], [-0.3162341605832586 0.4410185608089526 0.6775190618538066 0.3336809981458051; 1.7116615245412652 0.35751648886194604 -0.8628870265065961 -1.195470375407145; 1.2683824885596202 2.106437022846627 -2.341581668062198 -0.3755709619578594; -1.272062789754402 -1.1597991843364066 1.7767909510594972 0.4986289544382589]))
, [0.26686096499751677 0.13347269753366897 0.3196430110849233 0.8419908676476237; 0.6559056115790607 3.0495029976204893 3.2920065204492985 -3.2227056808361954; … ; 0.3666734338983696 0.73123403794996 2.6655741007828295 -0.8833723751836531; -0.28814178663132756 -1.708809012952866 -1.9517852999988166 1.5653470879092373]; rtol=1.0e-9, atol=1.0e-9)
Stacktrace:
 [1] #rrule_test#13(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}, ::Vararg{Tuple{Array{Float64,2},Array{Float64,2}},N} where N) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:195
 [2] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:175
 [3] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:74
 [4] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
 [5] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:70
 [6] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
 [7] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:67
 [8] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
 [9] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:4
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:6
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:8
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:21
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:22
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Array{Float64,2},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,2},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:23
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:24
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Symmetric: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#783#785&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#783#785&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:28
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:27
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Adjoint{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#786#788&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#786#788&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Adjoint{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#789#791&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#789#791&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Adjoint{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#792#794&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#792#794&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(adjoint), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Adjoint{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#795#797&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#795#797&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(adjoint), ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Transpose{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#798#800&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#798#800&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Transpose{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#801#803&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#801#803&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Transpose{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#804#806&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#804#806&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(transpose), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Transpose{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#807#809&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#807#809&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(transpose), ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
UpperTriangular: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#810#812&quot;{UpperTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#810#812&quot;{UpperTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::UpperTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::UpperTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:40
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:37
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
LowerTriangular: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#813#815&quot;{LowerTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#813#815&quot;{LowerTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::LowerTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::LowerTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:40
   [7] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:37
   [9] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
 ┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = rrule(::typeof(lgamma), ::Float64) at rule_definition_tools.jl:207
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:207
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = #test_scalar#3(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(test_scalar), ::typeof(lgamma), ::Float64) at test_util.jl:30
└ @ Main ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:30
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = fdm(::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::typeof(lgamma), ::Float64, ::Val{true}) at methods.jl:222
└ @ FiniteDifferences ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:222
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = #20 at methods.jl:263 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,UnitRange{Int64},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,UnitRange{Int64},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = frule(::typeof(lgamma), ::Float64) at rule_definition_tools.jl:178
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:178
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = rrule(::typeof(lgamma), ::Complex{Float64}) at rule_definition_tools.jl:207
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:207
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #test_scalar#3(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(test_scalar), ::typeof(lgamma), ::Complex{Float64}) at test_util.jl:30
└ @ Main ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:30
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = frule(::typeof(lgamma), ::Complex{Float64}) at rule_definition_tools.jl:178
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:178
Test Summary:                           | Pass  Fail  Error  Total
ChainRules                              | 7528     1     62   7591
  helper functions                      |   12                  12
  rulesets                              | 7516     1     62   7579
    Base                                | 1447            8   1455
      base                              | 1280            3   1283
        Trig                            |  568            1    569
          Basics                        |   56                  56
          Basics                        |   72                  72
          Hyperbolic                    |   42                  42
          Hyperbolic                    |   54                  54
          Degrees                       |   42                  42
          Inverses                      |   42                  42
          Inverses                      |   54                  54
          Inverse hyperbolic            |   42                  42
          Inverse hyperbolic            |   54                  54
          Inverse degrees               |   42                  42
          Inverse degrees               |   54                  54
          Multivariate                  |   14            1     15
            atan2                       |    5                   5
            sincos                      |    9            1     10
        math                            |  311                 311
        Unary complex functions         |  224                 224
        *(x, y)                         |   16                  16
        binary trig (hypot)             |   16                  16
        binary trig (atan)              |   16                  16
        identity                        |   17            2     19
        Constants                       |   14                  14
        Constants                       |   14                  14
        Constants                       |   18                  18
        Constants                       |   18                  18
        Constants                       |   18                  18
        sign                            |   30                  30
      reshape                           |    9                   9
      hcat                              |    5                   5
      vcat                              |    5                   5
      fill                              |    8                   8
      Maps and Reductions               |  132            5    137
        map                             |   33                  33
        mapreduce                       |   13            1     14
        mapfoldl                        |   13                  13
        mapfoldr                        |   13                  13
        sum                             |   60            4     64
          Vector                        |   12            1     13
          Matrix                        |   12            1     13
          Array{T, 3}                   |   12            1     13
          function argument             |   24                  24
          keyword arguments             |                 1      1
      broadcast                         |    8                   8
    Statistics                          |   22            2     24
      mean                              |   22            2     24
        Basic                           |   10            1     11
        with function arg               |   12                  12
        with dims kwargs                |                 1      1
    LinearAlgebra                       | 5136     1     49   5186
      linalg                            | 1298     1      4   1303
        dot                             |   66                  66
        inv                             |   12            1     13
        det                             |   12            1     13
        logdet                          |   12            1     13
        tr                              |   12            1     13
        *                               |  500                 500
        &#x2F;                               |  260                 260
        \                               |  359     1           360
          Matrix                        |  179     1           180
          Vector                        |   20                  20
          Diagonal on LHS               |   40                  40
          UpperTriangular on LHS        |   40                  40
          LowerTriangular on LHS        |   40                  40
          Matrix \ Vector               |   20                  20
          Vector \ Matrix               |   20                  20
        norm                            |   65                  65
      Structured Matrices               |  200           18    218
        Diagonal                        |   30            3     33
        ::Diagonal * ::AbstractVector   |   20                  20
        diag                            |   40            4     44
        Symmetric                       |   10            1     11
        Adjoint                         |   20            2     22
        adjoint                         |   20            2     22
        Transpose                       |   20            2     22
        transpose                       |   20            2     22
        UpperTriangular                 |   10            1     11
        LowerTriangular                 |   10            1     11
      Factorizations                    |  128           27    155
        svd                             |  102           27    129
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          accumulate!                   |    9                   9
          Helper functions              |    3                   3
        cholesky                        |   26                  26
      BLAS                              | 3510                3510
    packages                            |  911            3    914
      SpecialFunctions                  |  119                 119
      SpecialFunctions                  |   84                  84
      SpecialFunctions                  |   84                  84
      SpecialFunctions                  |  133                 133
      SpecialFunctions                  |  119                 119
      SpecialFunctions                  |   84                  84
      SpecialFunctions                  |  144                 144
      log gamma and co                  |  144            3    147
        lgamma at 1.5, rrule            |    4                   4
        lgamma at 1.5, frule            |    3                   3
        loggamma at 1.5, rrule          |    4                   4
        loggamma at 1.5, frule          |    3                   3
        lgamma at 2.5, rrule            |    4                   4
        lgamma at 2.5, frule            |    3                   3
        loggamma at 2.5, rrule          |    4                   4
        loggamma at 2.5, frule          |    3                   3
        lgamma at 10.5, rrule           |    4                   4
        lgamma at 10.5, frule           |    3                   3
        loggamma at 10.5, rrule         |    4                   4
        loggamma at 10.5, frule         |    3                   3
        lgamma at -0.6, rrule           |    4                   4
        lgamma at -0.6, frule           |    3                   3
        lgamma at -2.6, rrule           |    4                   4
        lgamma at -2.6, frule           |    3                   3
        lgamma at -3.3, rrule           |    4                   4
        lgamma at -3.3, frule           |    3                   3
        lgamma at 1.6 + 1.6im, rrule    |    5                   5
        lgamma at 1.6 + 1.6im, frule    |    4                   4
        loggamma at 1.6 + 1.6im, rrule  |    5                   5
        loggamma at 1.6 + 1.6im, frule  |    4                   4
        lgamma at 1.6 - 1.6im, rrule    |    5                   5
        lgamma at 1.6 - 1.6im, frule    |    4                   4
        loggamma at 1.6 - 1.6im, rrule  |    5                   5
        loggamma at 1.6 - 1.6im, frule  |    4                   4
        lgamma at -4.6 + 1.6im, rrule   |    5                   5
        lgamma at -4.6 + 1.6im, frule   |    4                   4
        loggamma at -4.6 + 1.6im, rrule |    5                   5
        loggamma at -4.6 + 1.6im, frule |    4                   4
ERROR: LoadError: Some tests did not pass: 7528 passed, 1 failed, 62 errored, 0 broken.
in expression starting at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;runtests.jl:22
ERROR: Package ChainRules errored during testing
Stacktrace:
 [1] pkgerror(::String, ::Vararg{String,N} where N) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;Types.jl:113
 [2] #test#131(::Bool, ::Nothing, ::Cmd, ::Cmd, ::typeof(Pkg.Operations.test), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;Operations.jl:1370
 [3] #test at .&#x2F;none:0 [inlined]
 [4] #test#62(::Bool, ::Nothing, ::Cmd, ::Cmd, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.test), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:253
 [5] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:239
 [6] #test#61 at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:233 [inlined]
 [7] test at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:233 [inlined]
 [8] #test#60 at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:232 [inlined]
 [9] test at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:232 [inlined]
 [10] #test#59(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.test), ::String) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:231
 [11] test(::String) at &#x2F;buildworker&#x2F;worker&#x2F;package_linux64&#x2F;build&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:231
 [12] top-level scope at none:10
</pre>
      </div>

    <h3>Results with Julia v1.3.1-pre-7704df0a5a</h3>

    <p>
      Testing was <strong>unsuccessful</strong>: package has test failures.
      Last evaluation was  ago and took 15 minutes, 22 seconds.
    </p>

    <p>
      Click <a href="/home/maleadt/Julia/pkg/NewPkgEval/site/build/logs/ChainRules/1.3.1-pre-7704df0a5a.log">here</a> to download the log file.
      
    </p>

      <button class="collapsible">Click here to show the log contents.</button>
      <div class="content">
      <pre> Resolving package versions...
 Installed Reexport ─────── v0.2.0
 Installed ChainRulesCore ─ v0.4.0
 Installed Requires ─────── v0.5.2
 Installed ChainRules ───── v0.2.3
  Updating `~&#x2F;.julia&#x2F;environments&#x2F;v1.3&#x2F;Project.toml`
  [082447d4] + ChainRules v0.2.3
  Updating `~&#x2F;.julia&#x2F;environments&#x2F;v1.3&#x2F;Manifest.toml`
  [082447d4] + ChainRules v0.2.3
  [d360d2e6] + ChainRulesCore v0.4.0
  [189a3867] + Reexport v0.2.0
  [ae029012] + Requires v0.5.2
  [2a0f44e3] + Base64 
  [ade2ca70] + Dates 
  [8ba89e20] + Distributed 
  [b77e0a4c] + InteractiveUtils 
  [76f85450] + LibGit2 
  [8f399da3] + Libdl 
  [37e2e46d] + LinearAlgebra 
  [56ddb016] + Logging 
  [d6f4376e] + Markdown 
  [44cfe95a] + Pkg 
  [de0858da] + Printf 
  [3fa0cd96] + REPL 
  [9a3f8284] + Random 
  [ea8e919c] + SHA 
  [9e88b42a] + Serialization 
  [6462fe0b] + Sockets 
  [2f01184e] + SparseArrays 
  [10745b16] + Statistics 
  [8dfed614] + Test 
  [cf7118a7] + UUIDs 
  [4ec0a83e] + Unicode 
   Testing ChainRules
 Resolving package versions...
 Installed NaNMath ─────────── v0.3.3
 Installed OpenSpecFun_jll ─── v0.5.3+1
 Installed SpecialFunctions ── v0.9.0
 Installed FiniteDifferences ─ v0.9.0
    Status `&#x2F;tmp&#x2F;jl_a7EXSJ&#x2F;Manifest.toml`
  [082447d4] ChainRules v0.2.3
  [d360d2e6] ChainRulesCore v0.4.0
  [26cc04aa] FiniteDifferences v0.9.0
  [77ba4419] NaNMath v0.3.3
  [efe28fd5] OpenSpecFun_jll v0.5.3+1
  [189a3867] Reexport v0.2.0
  [ae029012] Requires v0.5.2
  [276daf66] SpecialFunctions v0.9.0
  [2a0f44e3] Base64  [`@stdlib&#x2F;Base64`]
  [ade2ca70] Dates  [`@stdlib&#x2F;Dates`]
  [8ba89e20] Distributed  [`@stdlib&#x2F;Distributed`]
  [b77e0a4c] InteractiveUtils  [`@stdlib&#x2F;InteractiveUtils`]
  [76f85450] LibGit2  [`@stdlib&#x2F;LibGit2`]
  [8f399da3] Libdl  [`@stdlib&#x2F;Libdl`]
  [37e2e46d] LinearAlgebra  [`@stdlib&#x2F;LinearAlgebra`]
  [56ddb016] Logging  [`@stdlib&#x2F;Logging`]
  [d6f4376e] Markdown  [`@stdlib&#x2F;Markdown`]
  [44cfe95a] Pkg  [`@stdlib&#x2F;Pkg`]
  [de0858da] Printf  [`@stdlib&#x2F;Printf`]
  [3fa0cd96] REPL  [`@stdlib&#x2F;REPL`]
  [9a3f8284] Random  [`@stdlib&#x2F;Random`]
  [ea8e919c] SHA  [`@stdlib&#x2F;SHA`]
  [9e88b42a] Serialization  [`@stdlib&#x2F;Serialization`]
  [6462fe0b] Sockets  [`@stdlib&#x2F;Sockets`]
  [2f01184e] SparseArrays  [`@stdlib&#x2F;SparseArrays`]
  [10745b16] Statistics  [`@stdlib&#x2F;Statistics`]
  [8dfed614] Test  [`@stdlib&#x2F;Test`]
  [cf7118a7] UUIDs  [`@stdlib&#x2F;UUIDs`]
  [4ec0a83e] Unicode  [`@stdlib&#x2F;Unicode`]
WARNING: Method definition rrule(typeof(Base.sum), AbstractArray{#s677, N} where N where #s677&lt;:Real) in module ChainRules at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;src&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:61 overwritten at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;src&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:76.
  ** incremental compilation may be fatally broken for this module **

Testing ChainRules.jl
sincos: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sincos), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:78
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:74
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:55
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:3
   [11] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
identity: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(identity), ::Float64, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Float64, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:152
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:151
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
identity: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(identity), ::Array{Float64,1}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:153
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:151
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;base.jl:2
  
mapreduce: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:25
  Test threw exception
  Expression: ≈(x̄_ad, x̄_fd, atol=1.0e-9, rtol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; atol=1.0e-9, rtol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(abs2),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(abs2),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:25
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:12
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Vector: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,1}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,1}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:39
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:37
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Matrix: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:44
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:42
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
Array{T, 3}: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,3}, ::Tuple{Array{Float64,3}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,3}}}, ::Tuple{Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Float64,typeof(identity),Array{Float64,3}}}, ::Tuple{Array{Float64,3}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(sum), ::Float64, ::Tuple{Array{Float64,3},Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,3},Array{Float64,3}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:49
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:47
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [11] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [12] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
keyword arguments: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:65
  Test threw exception
  Expression: ≈(x̄_ad, x̄_fd, atol=1.0e-9, rtol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; atol=1.0e-9, rtol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#600#603&quot;{Array{Float64,2},typeof(identity),Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:65
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:58
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:36
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Base&#x2F;mapreduce.jl:2
  
 Basic: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#630#632&quot;{Float64,ChainRules.var&quot;#sum_pullback#622&quot;{ChainRules.var&quot;#sum_pullback#620&quot;{ChainRules.var&quot;#mapreduce_pullback#602&quot;{typeof(identity),Array{Float64,1}}}},Int64}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#630#632&quot;{Float64,ChainRules.var&quot;#sum_pullback#622&quot;{ChainRules.var&quot;#sum_pullback#620&quot;{ChainRules.var&quot;#mapreduce_pullback#602&quot;{typeof(identity),Array{Float64,1}}}},Int64}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(mean), ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:6
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:6
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:2
  
with dims kwargs: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:31
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-9, atol=1.0e-9)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:31
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:25
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;Statistics&#x2F;statistics.jl:2
  
 inv: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(inv), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:37
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:34
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
det: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#724#726&quot;{Float64,Array{Float64,2},Float64}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#724#726&quot;{Float64,Array{Float64,2},Float64}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(det), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:43
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:40
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
logdet: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#728#730&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#728#730&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logdet), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:49
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:46
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
tr: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#732#734&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#732#734&quot;{Float64,Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(tr), ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Float64, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:54
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:52
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
  
Matrix: Test Failed at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:195
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
   Evaluated: isapprox(Thunk(ChainRules.var&quot;#755#758&quot;{Array{Float64,2},Array{Float64,2},Array{Float64,2},Array{Float64,2}}([-0.9827718177516547 -3.049187087985662 -0.45753014518031915 0.049550548181828; -1.1457095184571038 -1.281790532097414 -0.7991285413217107 -0.8913053693383933; 0.25819205428715203 2.8015194483397003 1.0753460926351635 -0.7053146611866707; -2.282547976724439 0.5639614209301308 -0.5569593865129592 1.3970437844025363], [-0.34807928510100733 0.8718983568753548 -1.3002596896606895 -0.4385362125324239; -0.19506959830062723 -0.007206357093314457 -1.0059040824152614 -0.09173118968880091; -0.5497606187369344 -0.6163495955240155 0.6796485760534101 1.22561207137653; 1.0808323747949233 -0.5801739513350528 -0.043207370167515954 -0.232131676978592; -2.2125060475463463 -1.5612897485472592 -0.039839626218822005 -1.2139396904067505], [-0.23690460123730323 -1.7170129974387656 1.604831121738095 -0.330419660506073; -0.3827075659919168 -2.446261897220929 1.7480788262457672 -0.2672312785080624; -1.9688978438045297 -0.26713540122649804 0.9166815687612451 1.200964147356692; -1.5797479817238906 0.6778692338783507 1.1341703209400371 1.3170491877286854; -0.5654974841550139 -0.1689008828898645 -2.1775754411288144 0.6023924017880021], [-0.3162341605832586 0.4410185608089526 0.6775190618538066 0.3336809981458051; 1.7116615245412652 0.35751648886194604 -0.8628870265065961 -1.195470375407145; 1.2683824885596202 2.106437022846627 -2.341581668062198 -0.3755709619578594; -1.272062789754402 -1.1597991843364066 1.7767909510594972 0.4986289544382589]))
, [0.26686096499751677 0.13347269753366897 0.3196430110849233 0.8419908676476237; 0.6559056115790607 3.0495029976204893 3.2920065204492985 -3.2227056808361954; … ; 0.3666734338983696 0.73123403794996 2.6655741007828295 -0.8833723751836531; -0.28814178663132756 -1.708809012952866 -1.9517852999988166 1.5653470879092373]; rtol=1.0e-9, atol=1.0e-9)
Stacktrace:
 [1] #rrule_test#13(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}, ::Vararg{Tuple{Array{Float64,2},Array{Float64,2}},N} where N) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:195
 [2] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:175
 [3] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:74
 [4] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
 [5] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:70
 [6] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
 [7] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:67
 [8] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
 [9] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;dense.jl:7
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:4
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:6
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Diagonal: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,1}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#772#774&quot;{Diagonal{Float64,Array{Float64,1}}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:8
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:3
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:21
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:22
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Array{Float64,2},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Array{Float64,2},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:23
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
diag: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Diagonal{Float64,Array{Float64,1}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#775#777&quot;{Array{Float64,1}}}, ::Tuple{Diagonal{Float64,Array{Float64,1}}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(diag), ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,1}, ::Tuple{Diagonal{Float64,Array{Float64,1}},Diagonal{Float64,Array{Float64,1}}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:24
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:20
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Symmetric: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#783#785&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#783#785&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:28
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:27
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Adjoint{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#786#788&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#786#788&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Adjoint{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#789#791&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#789#791&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Adjoint{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#792#794&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#792#794&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(adjoint), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
adjoint: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Adjoint{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#795#797&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#795#797&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(adjoint), ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Transpose{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#798#800&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#798#800&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
Transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Transpose{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#801#803&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#801#803&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Transpose{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#804#806&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#804#806&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(transpose), ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:34
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
transpose: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Base.ReshapedArray{Float64,1,Transpose{Float64,Array{Float64,2}},Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}}, ::Tuple{Array{Float64,1}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#807#809&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#807#809&quot;{Array{Float64,2}}}, ::Tuple{Array{Float64,1}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(transpose), ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Function, ::Array{Float64,2}, ::Tuple{Array{Float64,1},Array{Float64,1}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:35
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:30
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
UpperTriangular: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#810#812&quot;{UpperTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#810#812&quot;{UpperTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::UpperTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::UpperTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:40
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:37
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
LowerTriangular: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] #isapprox#16(::Base.Iterators.Pairs{Symbol,Float64,Tuple{Symbol,Symbol},NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#813#815&quot;{LowerTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:216
   [2] (::Base.var&quot;#kw##isapprox&quot;)(::NamedTuple{(:rtol, :atol),Tuple{Float64,Float64}}, ::typeof(isapprox), ::Thunk{ChainRules.var&quot;#813#815&quot;{LowerTriangular{Float64,Array{Float64,2}}}}, ::Tuple{Array{Float64,2}}) at .&#x2F;none:0
   [3] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [4] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::Type, ::LowerTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [5] rrule_test(::Type, ::LowerTriangular{Float64,Array{Float64,2}}, ::Tuple{Array{Float64,2},Array{Float64,2}}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:40
   [7] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1180
   [8] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:37
   [9] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [10] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;structured.jl:2
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
svd: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
  Test threw exception
  Expression: ≈(X̄_ad, X̄_fd, rtol=1.0e-6, atol=1.0e-6)
  MethodError: no method matching isapprox(::Array{Float64,2}, ::Tuple{Array{Float64,2}}; rtol=1.0e-6, atol=1.0e-6)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::AbstractArray, !Matched::AbstractArray; atol, rtol, nans, norm) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;LinearAlgebra&#x2F;src&#x2F;generic.jl:1522
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:22
   [3] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:5
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;LinearAlgebra&#x2F;factorization.jl:4
  
 ┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = rrule(::typeof(lgamma), ::Float64) at rule_definition_tools.jl:207
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:207
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = #test_scalar#3(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(test_scalar), ::typeof(lgamma), ::Float64) at test_util.jl:30
└ @ Main ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:30
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = fdm(::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::typeof(lgamma), ::Float64, ::Val{true}) at methods.jl:222
└ @ FiniteDifferences ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:222
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,Array{Int64,1},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = #20 at methods.jl:263 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,UnitRange{Int64},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = _mapreduce(::FiniteDifferences.var&quot;#20#22&quot;{typeof(lgamma),Float64,UnitRange{Int64},Array{Float64,1},Float64}, ::typeof(Base.add_sum), ::IndexLinear, ::Base.OneTo{Int64}) at methods.jl:263
└ @ Base ~&#x2F;.julia&#x2F;packages&#x2F;FiniteDifferences&#x2F;SExlu&#x2F;src&#x2F;methods.jl:263
┌ Warning: `lgamma(x::Real)` is deprecated, use `(logabsgamma(x))[1]` instead.
│   caller = frule(::typeof(lgamma), ::Float64) at rule_definition_tools.jl:178
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:178
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
log gamma and co: Error During Test at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
  Test threw exception
  Expression: isapprox(x̄_ad, x̄_fd; rtol=rtol, atol=atol, kwargs...)
  MethodError: no method matching isapprox(::Float64, ::Tuple{Float64}; rtol=1.0e-9, atol=1.0e-9)
  Closest candidates are:
    isapprox(!Matched::Missing, ::Any; kwargs...) at missing.jl:90
    isapprox(::Any, !Matched::Missing; kwargs...) at missing.jl:91
    isapprox(::Number, !Matched::Number; atol, rtol, nans) at floatfuncs.jl:274
    ...
  Stacktrace:
   [1] eval_test(::Expr, ::Expr, ::LineNumberNode, ::Bool) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:257
   [2] #rrule_test#12(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(rrule_test), ::typeof(logabsgamma), ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:140
   [3] rrule_test(::Function, ::Tuple{Float64,Float64}, ::Tuple{Float64,Float64}) at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:124
   [4] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:56
   [5] top-level scope at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Test&#x2F;src&#x2F;Test.jl:1107
   [6] top-level scope at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;rulesets&#x2F;packages&#x2F;SpecialFunctions.jl:40
  
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = rrule(::typeof(lgamma), ::Complex{Float64}) at rule_definition_tools.jl:207
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:207
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #test_scalar#3(::Float64, ::Float64, ::FiniteDifferences.Central{UnitRange{Int64},Array{Float64,1}}, ::Bool, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(test_scalar), ::typeof(lgamma), ::Complex{Float64}) at test_util.jl:30
└ @ Main ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:30
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #4 at test_util.jl:50 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:50
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = #5 at test_util.jl:51 [inlined]
└ @ Core ~&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;test_util.jl:51
┌ Warning: `lgamma(x::Number)` is deprecated, use `loggamma(x)` instead.
│   caller = frule(::typeof(lgamma), ::Complex{Float64}) at rule_definition_tools.jl:178
└ @ ChainRules.SpecialFunctionsGlue ~&#x2F;.julia&#x2F;packages&#x2F;ChainRulesCore&#x2F;7Zuuq&#x2F;src&#x2F;rule_definition_tools.jl:178
Test Summary:                           | Pass  Fail  Error  Total
ChainRules                              | 7528     1     62   7591
  helper functions                      |   12                  12
  rulesets                              | 7516     1     62   7579
    Base                                | 1447            8   1455
      base                              | 1280            3   1283
        Trig                            |  568            1    569
          Basics                        |   56                  56
          Basics                        |   72                  72
          Hyperbolic                    |   42                  42
          Hyperbolic                    |   54                  54
          Degrees                       |   42                  42
          Inverses                      |   42                  42
          Inverses                      |   54                  54
          Inverse hyperbolic            |   42                  42
          Inverse hyperbolic            |   54                  54
          Inverse degrees               |   42                  42
          Inverse degrees               |   54                  54
          Multivariate                  |   14            1     15
            atan2                       |    5                   5
            sincos                      |    9            1     10
        math                            |  311                 311
        Unary complex functions         |  224                 224
        *(x, y)                         |   16                  16
        binary trig (hypot)             |   16                  16
        binary trig (atan)              |   16                  16
        identity                        |   17            2     19
        Constants                       |   14                  14
        Constants                       |   14                  14
        Constants                       |   18                  18
        Constants                       |   18                  18
        Constants                       |   18                  18
        sign                            |   30                  30
      reshape                           |    9                   9
      hcat                              |    5                   5
      vcat                              |    5                   5
      fill                              |    8                   8
      Maps and Reductions               |  132            5    137
        map                             |   33                  33
        mapreduce                       |   13            1     14
        mapfoldl                        |   13                  13
        mapfoldr                        |   13                  13
        sum                             |   60            4     64
          Vector                        |   12            1     13
          Matrix                        |   12            1     13
          Array{T, 3}                   |   12            1     13
          function argument             |   24                  24
          keyword arguments             |                 1      1
      broadcast                         |    8                   8
    Statistics                          |   22            2     24
      mean                              |   22            2     24
        Basic                           |   10            1     11
        with function arg               |   12                  12
        with dims kwargs                |                 1      1
    LinearAlgebra                       | 5136     1     49   5186
      linalg                            | 1298     1      4   1303
        dot                             |   66                  66
        inv                             |   12            1     13
        det                             |   12            1     13
        logdet                          |   12            1     13
        tr                              |   12            1     13
        *                               |  500                 500
        &#x2F;                               |  260                 260
        \                               |  359     1           360
          Matrix                        |  179     1           180
          Vector                        |   20                  20
          Diagonal on LHS               |   40                  40
          UpperTriangular on LHS        |   40                  40
          LowerTriangular on LHS        |   40                  40
          Matrix \ Vector               |   20                  20
          Vector \ Matrix               |   20                  20
        norm                            |   65                  65
      Structured Matrices               |  200           18    218
        Diagonal                        |   30            3     33
        ::Diagonal * ::AbstractVector   |   20                  20
        diag                            |   40            4     44
        Symmetric                       |   10            1     11
        Adjoint                         |   20            2     22
        adjoint                         |   20            2     22
        Transpose                       |   20            2     22
        transpose                       |   20            2     22
        UpperTriangular                 |   10            1     11
        LowerTriangular                 |   10            1     11
      Factorizations                    |  128           27    155
        svd                             |  102           27    129
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          Vt                            |    1                   1
          accumulate!                   |    9                   9
          Helper functions              |    3                   3
        cholesky                        |   26                  26
      BLAS                              | 3510                3510
    packages                            |  911            3    914
      SpecialFunctions                  |  119                 119
      SpecialFunctions                  |   84                  84
      SpecialFunctions                  |   84                  84
      SpecialFunctions                  |  133                 133
      SpecialFunctions                  |  119                 119
      SpecialFunctions                  |   84                  84
      SpecialFunctions                  |  144                 144
      log gamma and co                  |  144            3    147
        lgamma at 1.5, rrule            |    4                   4
        lgamma at 1.5, frule            |    3                   3
        loggamma at 1.5, rrule          |    4                   4
        loggamma at 1.5, frule          |    3                   3
        lgamma at 2.5, rrule            |    4                   4
        lgamma at 2.5, frule            |    3                   3
        loggamma at 2.5, rrule          |    4                   4
        loggamma at 2.5, frule          |    3                   3
        lgamma at 10.5, rrule           |    4                   4
        lgamma at 10.5, frule           |    3                   3
        loggamma at 10.5, rrule         |    4                   4
        loggamma at 10.5, frule         |    3                   3
        lgamma at -0.6, rrule           |    4                   4
        lgamma at -0.6, frule           |    3                   3
        lgamma at -2.6, rrule           |    4                   4
        lgamma at -2.6, frule           |    3                   3
        lgamma at -3.3, rrule           |    4                   4
        lgamma at -3.3, frule           |    3                   3
        lgamma at 1.6 + 1.6im, rrule    |    5                   5
        lgamma at 1.6 + 1.6im, frule    |    4                   4
        loggamma at 1.6 + 1.6im, rrule  |    5                   5
        loggamma at 1.6 + 1.6im, frule  |    4                   4
        lgamma at 1.6 - 1.6im, rrule    |    5                   5
        lgamma at 1.6 - 1.6im, frule    |    4                   4
        loggamma at 1.6 - 1.6im, rrule  |    5                   5
        loggamma at 1.6 - 1.6im, frule  |    4                   4
        lgamma at -4.6 + 1.6im, rrule   |    5                   5
        lgamma at -4.6 + 1.6im, frule   |    4                   4
        loggamma at -4.6 + 1.6im, rrule |    5                   5
        loggamma at -4.6 + 1.6im, frule |    4                   4
ERROR: LoadError: Some tests did not pass: 7528 passed, 1 failed, 62 errored, 0 broken.
in expression starting at &#x2F;root&#x2F;.julia&#x2F;packages&#x2F;ChainRules&#x2F;ziOpP&#x2F;test&#x2F;runtests.jl:22
ERROR: Package ChainRules errored during testing
Stacktrace:
 [1] pkgerror(::String, ::Vararg{String,N} where N) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;Types.jl:113
 [2] #test#131(::Bool, ::Nothing, ::Cmd, ::Cmd, ::typeof(Pkg.Operations.test), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;Operations.jl:1370
 [3] #test at .&#x2F;none:0 [inlined]
 [4] #test#62(::Bool, ::Nothing, ::Cmd, ::Cmd, ::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.test), ::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:253
 [5] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:239
 [6] #test#61 at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:233 [inlined]
 [7] test at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:233 [inlined]
 [8] #test#60 at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:232 [inlined]
 [9] test at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:232 [inlined]
 [10] #test#59(::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}, ::typeof(Pkg.API.test), ::String) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:231
 [11] test(::String) at &#x2F;workspace&#x2F;srcdir&#x2F;julia&#x2F;usr&#x2F;share&#x2F;julia&#x2F;stdlib&#x2F;v1.3&#x2F;Pkg&#x2F;src&#x2F;API.jl:231
 [12] top-level scope at none:10
</pre>
      </div>


  </div>
  </body>

  <script type="text/javascript">// handle collapsibles
var coll = document.getElementsByClassName("collapsible");
for (var i = 0; i < coll.length; i++) {
    coll[i].textContent = "▸ " + coll[i].textContent
    coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.display === "block") {
            this.textContent = "▸" + this.textContent.substr(1)
            content.style.display = "none";
        } else {
            this.textContent = "▾" + this.textContent.substr(1)
            content.style.display = "block";
        }
    });
}
</script>
</html>

